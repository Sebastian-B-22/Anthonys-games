<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knight's Quest - Metroidvania</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a1a;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        canvas {
            display: block;
            background: white;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #333;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 2px white;
            pointer-events: none;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #666;
            font-size: 12px;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 5px;
        }
        .loading {
            color: white;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="800"></canvas>
        <div id="ui">
            <div id="health">‚ù§Ô∏è Health: 5/5</div>
            <div id="coins">üí∞ Coins: 0</div>
            <div id="room">üìç Starting Room</div>
        </div>
        <div id="controls">
            ‚¨ÖÔ∏è‚û°Ô∏è Move | ‚¨ÜÔ∏è Jump | X Attack | D Dash | S Defend | R Restart
        </div>
    </div>
    <script>
// Knight's Quest - JavaScript Metroidvania
// Note: Sprites removed for standalone version - using colored rectangles

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Game constants
const GRAVITY = 0.8;
const JUMP_POWER = -15;
const MOVE_SPEED = 5;
const RUN_SPEED = 8;
const DASH_SPEED = 20;
const DASH_DURATION = 15;

// Game state
const game = {
    player: null,
    keys: {},
    currentRoom: 'start',
    coins: 0,
    abilities: {
        doubleJump: false,
        dash: false
    }
};

// Player class
class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 40;
        this.height = 60;
        this.velocityX = 0;
        this.velocityY = 0;
        this.onGround = false;
        this.facingRight = true;
        this.health = 5;
        this.maxHealth = 5;
        this.jumpsLeft = 1;
        this.attacking = false;
        this.attackTimer = 0;
        this.dashing = false;
        this.dashTimer = 0;
        this.invincible = false;
        this.invincibleTimer = 0;
        this.defending = false;
        this.pickingUp = false;
        this.pickupTimer = 0;
        this.dying = false;
        this.deathTimer = 0;
    }
    
    update() {
        // Handle death animation
        if (this.dying) {
            this.deathTimer--;
            if (this.deathTimer <= 0) {
                this.respawn();
            }
            return;
        }
        
        // Handle pickup animation
        if (this.pickingUp) {
            this.pickupTimer--;
            if (this.pickupTimer <= 0) {
                this.pickingUp = false;
            }
            return;
        }
        
        // Handle invincibility
        if (this.invincible) {
            this.invincibleTimer--;
            if (this.invincibleTimer <= 0) {
                this.invincible = false;
            }
        }
        
        // Handle defending
        this.defending = game.keys['s'] && this.onGround;
        
        // Handle dashing
        if (this.dashing) {
            this.dashTimer--;
            if (this.dashTimer <= 0) {
                this.dashing = false;
                this.velocityX = 0;
            }
            return;
        }
        
        // Handle attacking
        if (this.attacking) {
            this.attackTimer--;
            if (this.attackTimer <= 0) {
                this.attacking = false;
            }
            this.velocityX *= 0.8;
        }
        
        // Horizontal movement
        if (!this.attacking && !this.dashing && !this.defending) {
            if (game.keys['ArrowLeft']) {
                this.velocityX = -MOVE_SPEED;
                this.facingRight = false;
            } else if (game.keys['ArrowRight']) {
                this.velocityX = MOVE_SPEED;
                this.facingRight = true;
            } else {
                this.velocityX *= 0.8;
                if (Math.abs(this.velocityX) < 0.1) this.velocityX = 0;
            }
        } else if (this.defending) {
            this.velocityX *= 0.9;
        }
        
        // Jumping
        if (game.keys['ArrowUp'] && !game.keys['ArrowUp_pressed']) {
            if (this.onGround) {
                this.velocityY = JUMP_POWER;
                this.jumpsLeft = game.abilities.doubleJump ? 1 : 0;
                game.keys['ArrowUp_pressed'] = true;
            } else if (this.jumpsLeft > 0) {
                this.velocityY = JUMP_POWER;
                this.jumpsLeft--;
                game.keys['ArrowUp_pressed'] = true;
            }
        }
        
        // Attacking
        if (game.keys['x'] && !game.keys['x_pressed'] && !this.attacking) {
            this.attacking = true;
            this.attackTimer = 20;
            game.keys['x_pressed'] = true;
            this.checkAttackHit();
        }
        
        // Dashing
        if (game.keys['d'] && !game.keys['d_pressed'] && game.abilities.dash && !this.dashing) {
            this.dashing = true;
            this.dashTimer = DASH_DURATION;
            this.velocityX = this.facingRight ? DASH_SPEED : -DASH_SPEED;
            this.velocityY = 0;
            game.keys['d_pressed'] = true;
        }
        
        // Apply gravity
        this.velocityY += GRAVITY;
        
        // Update position
        this.x += this.velocityX;
        this.y += this.velocityY;
        
        // Check collisions
        this.checkCollisions();
    }
    
    checkCollisions() {
        const room = rooms[game.currentRoom];
        this.onGround = false;
        
        // Floor collision
        if (this.y + this.height >= canvas.height) {
            this.y = canvas.height - this.height;
            this.velocityY = 0;
            this.onGround = true;
            this.jumpsLeft = game.abilities.doubleJump ? 2 : 1;
        }
        
        // Platform collisions
        room.platforms.forEach(platform => {
            if (this.velocityY >= 0 &&
                this.x + this.width > platform.x &&
                this.x < platform.x + platform.width &&
                this.y + this.height >= platform.y &&
                this.y + this.height <= platform.y + 20) {
                this.y = platform.y - this.height;
                this.velocityY = 0;
                this.onGround = true;
                this.jumpsLeft = game.abilities.doubleJump ? 2 : 1;
            }
        });
        
        // Wall collisions
        if (this.x < 0) this.x = 0;
        if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;
        if (this.y < 0) this.y = 0;
    }
    
    checkAttackHit() {
        const room = rooms[game.currentRoom];
        const attackRange = 80;
        const attackX = this.facingRight ? this.x + this.width : this.x - attackRange;
        
        room.enemies.forEach(enemy => {
            if (!enemy.dead &&
                enemy.x < attackX + attackRange &&
                enemy.x + enemy.width > attackX &&
                enemy.y < this.y + this.height &&
                enemy.y + enemy.height > this.y) {
                enemy.takeDamage(1);
            }
        });
    }
    
    takeDamage(amount) {
        if (this.invincible || this.dying) return;
        
        // Defend blocks 50% damage
        if (this.defending) {
            amount = Math.ceil(amount / 2);
            showMessage('Blocked!');
        }
        
        this.health -= amount;
        this.invincible = true;
        this.invincibleTimer = 60;
        
        if (this.health <= 0) {
            this.die();
        }
        
        updateUI();
    }
    
    die() {
        this.dying = true;
        this.deathTimer = 60;
        this.velocityX = 0;
        this.velocityY = 0;
    }
    
    respawn() {
        this.dying = false;
        this.health = this.maxHealth;
        this.x = 100;
        this.y = 100;
        this.velocityX = 0;
        this.velocityY = 0;
        game.currentRoom = 'start';
        game.coins = 0;
        updateUI();
    }
    
    draw() {
        ctx.save();
        
        // Flicker when invincible
        if (this.invincible && Math.floor(this.invincibleTimer / 5) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }
        
        // Draw player
        if (this.dying) {
            ctx.fillStyle = '#666';
        } else if (this.defending) {
            ctx.fillStyle = '#4fc3f7';
        } else if (this.attacking) {
            ctx.fillStyle = '#ff5722';
        } else if (this.dashing) {
            ctx.fillStyle = '#ff9800';
        } else {
            ctx.fillStyle = '#2196f3';
        }
        
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        // Draw direction indicator
        ctx.fillStyle = 'white';
        const eyeX = this.facingRight ? this.x + 30 : this.x + 10;
        ctx.fillRect(eyeX, this.y + 15, 5, 5);
        
        // Draw attack range
        if (this.attacking) {
            ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
            const attackX = this.facingRight ? this.x + this.width : this.x - 80;
            ctx.fillRect(attackX, this.y, 80, this.height);
        }
        
        ctx.restore();
    }
}

// Enemy class
class Enemy {
    constructor(x, y, type = 'knight') {
        this.x = x;
        this.y = y;
        this.width = 40;
        this.height = 60;
        this.type = type;
        this.health = 3;
        this.speed = 2;
        this.direction = 1;
        this.dead = false;
        this.patrolRange = 200;
        this.startX = x;
    }
    
    update() {
        if (this.dead) return;
        
        // Simple patrol AI
        this.x += this.speed * this.direction;
        
        if (this.x < this.startX - this.patrolRange || this.x > this.startX + this.patrolRange) {
            this.direction *= -1;
        }
        
        // Check collision with player
        if (!game.player.invincible &&
            this.x < game.player.x + game.player.width &&
            this.x + this.width > game.player.x &&
            this.y < game.player.y + game.player.height &&
            this.y + this.height > game.player.y) {
            game.player.takeDamage(1);
        }
    }
    
    takeDamage(amount) {
        this.health -= amount;
        if (this.health <= 0) {
            this.dead = true;
            game.coins += 10;
            updateUI();
        }
    }
    
    draw() {
        if (this.dead) return;
        
        ctx.fillStyle = '#333';
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        // Draw health bar
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x, this.y - 10, this.width, 5);
        ctx.fillStyle = 'green';
        ctx.fillRect(this.x, this.y - 10, this.width * (this.health / 3), 5);
    }
}

// Item class
class Item {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.width = 30;
        this.height = 30;
        this.type = type;
        this.collected = false;
    }
    
    update() {
        if (this.collected) return;
        
        // Check collision with player
        if (game.player.x < this.x + this.width &&
            game.player.x + game.player.width > this.x &&
            game.player.y < this.y + this.height &&
            game.player.y + game.player.height > this.y) {
            this.collect();
        }
    }
    
    collect() {
        this.collected = true;
        
        // Trigger pickup animation
        game.player.pickingUp = true;
        game.player.pickupTimer = 30;
        game.player.velocityX = 0;
        
        if (this.type === 'doubleJump') {
            game.abilities.doubleJump = true;
            showMessage('Double Jump unlocked!');
        } else if (this.type === 'dash') {
            game.abilities.dash = true;
            showMessage('Dash unlocked! Press D');
        } else if (this.type === 'coin') {
            game.coins += 50;
            updateUI();
        }
    }
    
    draw() {
        if (this.collected) return;
        
        if (this.type === 'doubleJump') {
            ctx.fillStyle = '#4fc3f7';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText('‚¨ÜÔ∏è‚¨ÜÔ∏è', this.x + 5, this.y + 22);
        } else if (this.type === 'dash') {
            ctx.fillStyle = '#ff9800';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText('üí®', this.x + 5, this.y + 22);
        } else if (this.type === 'coin') {
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText('üí∞', this.x + 5, this.y + 22);
        }
    }
}

// Room definitions
const rooms = {
    start: {
        name: 'Starting Hall',
        platforms: [
            { x: 200, y: 600, width: 400, height: 20 }
        ],
        enemies: [],
        items: [
            new Item(500, 550, 'coin')
        ],
        exits: [
            { x: canvas.width - 50, y: 0, width: 50, height: canvas.height, to: 'combat1' }
        ]
    },
    combat1: {
        name: 'Knight Chamber',
        platforms: [
            { x: 100, y: 500, width: 300, height: 20 },
            { x: 600, y: 400, width: 300, height: 20 },
            { x: 300, y: 300, width: 200, height: 20 }
        ],
        enemies: [
            new Enemy(150, 440),
            new Enemy(650, 340)
        ],
        items: [],
        exits: [
            { x: 0, y: 0, width: 50, height: canvas.height, to: 'start' },
            { x: canvas.width - 50, y: 0, width: 50, height: canvas.height, to: 'powerup1' }
        ]
    },
    powerup1: {
        name: 'Ancient Shrine',
        platforms: [
            { x: 400, y: 500, width: 400, height: 20 }
        ],
        enemies: [],
        items: [
            new Item(565, 450, 'doubleJump')
        ],
        exits: [
            { x: 0, y: 0, width: 50, height: canvas.height, to: 'combat1' },
            { x: canvas.width - 50, y: 0, width: 50, height: canvas.height, to: 'combat2' }
        ]
    },
    combat2: {
        name: 'Guardian Hall',
        platforms: [
            { x: 200, y: 600, width: 200, height: 20 },
            { x: 600, y: 500, width: 200, height: 20 },
            { x: 400, y: 350, width: 200, height: 20 }
        ],
        enemies: [
            new Enemy(250, 540),
            new Enemy(650, 440),
            new Enemy(450, 290)
        ],
        items: [],
        exits: [
            { x: 0, y: 0, width: 50, height: canvas.height, to: 'powerup1' },
            { x: canvas.width - 50, y: 0, width: 50, height: canvas.height, to: 'powerup2' }
        ]
    },
    powerup2: {
        name: 'Windswept Peak',
        platforms: [
            { x: 400, y: 450, width: 400, height: 20 }
        ],
        enemies: [],
        items: [
            new Item(565, 400, 'dash')
        ],
        exits: [
            { x: 0, y: 0, width: 50, height: canvas.height, to: 'combat2' }
        ]
    }
};

// Show message
function showMessage(text) {
    const msgDiv = document.createElement('div');
    msgDiv.textContent = text;
    msgDiv.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0,0,0,0.8);
        color: white;
        padding: 20px 40px;
        border-radius: 10px;
        font-size: 24px;
        z-index: 1000;
    `;
    document.body.appendChild(msgDiv);
    setTimeout(() => msgDiv.remove(), 2000);
}

// Update UI
function updateUI() {
    document.getElementById('health').textContent = `‚ù§Ô∏è Health: ${game.player.health}/${game.player.maxHealth}`;
    document.getElementById('coins').textContent = `üí∞ Coins: ${game.coins}`;
    document.getElementById('room').textContent = `üìç ${rooms[game.currentRoom].name}`;
}

// Input handling
window.addEventListener('keydown', (e) => {
    game.keys[e.key] = true;
    
    // Restart
    if (e.key === 'r') {
        game.player.die();
    }
});

window.addEventListener('keyup', (e) => {
    game.keys[e.key] = false;
    game.keys[e.key + '_pressed'] = false;
});

// Initialize game
function init() {
    game.player = new Player(100, 100);
    updateUI();
    gameLoop();
}

// Check room transitions
function checkRoomTransitions() {
    const room = rooms[game.currentRoom];
    
    room.exits.forEach(exit => {
        if (game.player.x < exit.x + exit.width &&
            game.player.x + game.player.width > exit.x &&
            game.player.y < exit.y + exit.height &&
            game.player.y + game.player.height > exit.y) {
            
            // Change room
            game.currentRoom = exit.to;
            
            // Position player at opposite side
            if (exit.x < canvas.width / 2) {
                game.player.x = canvas.width - 100;
            } else {
                game.player.x = 100;
            }
            game.player.y = 100;
            
            updateUI();
        }
    });
}

// Game loop
function gameLoop() {
    // Clear canvas
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Get current room
    const room = rooms[game.currentRoom];
    
    // Draw platforms
    ctx.fillStyle = '#999';
    room.platforms.forEach(platform => {
        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
    });
    
    // Draw exits
    ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
    room.exits.forEach(exit => {
        ctx.fillRect(exit.x, exit.y, exit.width, exit.height);
    });
    
    // Update and draw items
    room.items.forEach(item => {
        item.update();
        item.draw();
    });
    
    // Update and draw enemies
    room.enemies.forEach(enemy => {
        enemy.update();
        enemy.draw();
    });
    
    // Update and draw player
    game.player.update();
    game.player.draw();
    
    // Check room transitions
    checkRoomTransitions();
    
    requestAnimationFrame(gameLoop);
}

// Start game immediately
init();
    </script>
</body>
</html>
